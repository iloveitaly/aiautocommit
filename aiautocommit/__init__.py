import logging
import os
import re
import shutil
import subprocess
import warnings
from pathlib import Path
from typing import List


def update_env_variables():
    """
    Allow keys specific to AIAUTOCOMMIT to be set globally so project-specific keys can be used for AI calls
    """
    prefix = "AIAUTOCOMMIT_"
    # Create a list copy of keys to avoid "dictionary changed size during iteration" errors
    # as we update os.environ within the loop.
    for key in list(os.environ.keys()):
        if key.startswith(prefix):
            base_key = key[len(prefix) :]
            # AIAUTOCOMMIT_ prefixed variables take precedence over existing variables
            os.environ[base_key] = os.environ[key]


update_env_variables()

import click  # noqa: E402
from pydantic_ai import Agent  # noqa: E402
from pydantic_ai.models import infer_model  # noqa: E402

from .difftastic import get_difftastic_diff  # noqa: E402
from .internet import wait_for_internet_connection  # noqa: E402
from .log import log  # noqa: E402
from .utils import run_command  # noqa: E402

try:
    from importlib.metadata import PackageNotFoundError, version
    __version__ = version("aiautocommit")
except (ImportError, PackageNotFoundError):
    # Package is not installed in the environment (e.g. running from source during development)
    __version__ = "unknown"


# Config file locations in priority order
LOCAL_REPO_AUTOCOMMIT_DIR_NAME = ".aiautocommit"
CONFIG_PATHS = [
    Path(LOCAL_REPO_AUTOCOMMIT_DIR_NAME),  # $PWD/.aiautocommit
    Path(os.environ.get("XDG_CONFIG_HOME", "~/.config")).expanduser()
    / "aiautocommit",  # XDG config dir
    Path(__file__).parent / "prompt",  # package config dir
]

if custom_config_path := os.environ.get("AIAUTOCOMMIT_CONFIG", None):
    CONFIG_PATHS.insert(-2, Path(custom_config_path))

COMMIT_PROMPT_FILE = "commit_prompt.txt"
EXCLUSIONS_FILE = "excluded_files.txt"
COMMIT_SUFFIX_FILE = "commit_suffix.txt"

# https://ai.pydantic.dev/models/overview
MODEL_NAME = os.environ.get("AIAUTOCOMMIT_MODEL", "gemini:gemini-3-flash-preview")

COMMIT_PROMPT = ""
EXCLUDED_FILES = []

# trailers are a native git feature that can be used to add metadata to a commit
# https://git-scm.com/docs/git-interpret-trailers
# GitHub requires two blank lines before trailers for some features to work correctly
# See: https://github.com/orgs/community/discussions/143092
# Note: This may require `git commit --cleanup=verbatim` to prevent git from collapsing the blank lines.
# let's indicate that this message was generated by aiautocommit
COMMIT_SUFFIX = ""

# characters, not tokens
PROMPT_CUTOFF = 10_000

LOCK_FILE_MESSAGES = {
    "uv.lock": "chore(deps): update uv.lock",
    "poetry.lock": "chore(deps): update poetry.lock",
    "Pipfile.lock": "chore(deps): update Pipfile.lock",
    "package-lock.json": "chore(deps): update package-lock.json",
    "yarn.lock": "chore(deps): update yarn.lock",
    "pnpm-lock.yaml": "chore(deps): update pnpm-lock.yaml",
    "bun.lockb": "chore(deps): update bun.lockb",
    "Gemfile.lock": "chore(deps): update Gemfile.lock",
    "composer.lock": "chore(deps): update composer.lock",
    "mix.lock": "chore(deps): update mix.lock",
    "Cargo.lock": "chore(deps): update Cargo.lock",
    "go.sum": "chore(deps): update go.sum",
    ".terraform.lock.hcl": "chore(deps): update .terraform.lock.hcl",
}


# this is called within py dev environments. Unless it looks like we are explicitly debugging aiautocommit, we force a
# more silent operation. Checking for AIAUTOCOMMIT_LOG_PATH is not a perfect heuristic, but it works for now.
if not os.environ.get("AIAUTOCOMMIT_LOG_PATH"):
    # Suppress ResourceWarnings
    warnings.filterwarnings("ignore", category=ResourceWarning)

    # Optional: Disable httpx logging if desired
    logging.getLogger("httpx").setLevel(logging.WARNING)


def configure_prompts(config_dir=None):
    global COMMIT_PROMPT, COMMIT_SUFFIX, EXCLUDED_FILES, CONFIG_PATHS

    # Use custom config_dir if provided; otherwise use the default prompt directory
    if config_dir:
        CONFIG_PATHS.insert(0, Path(config_dir))

    # Find first existing config dir
    config_dir = next((path for path in CONFIG_PATHS if path and path.exists()), None)

    if not config_dir:
        log.debug("No config directory found")
        return

    log.debug(f"Found config directory at {config_dir}")

    commit_file = config_dir / COMMIT_PROMPT_FILE
    if commit_file.exists():
        log.debug("Loading commit prompt")
        COMMIT_PROMPT = commit_file.read_text().strip()
    else:
        log.debug(f"'commit_prompt.txt' does not exist in {config_dir}")

    examples_dir = config_dir / "examples"
    if examples_dir.exists():
        log.debug("Loading examples")
        pattern = re.compile(r"example_\d\.md$")
        example_files = sorted(
            [
                file
                for file in examples_dir.iterdir()
                if file.is_file() and pattern.match(file.name)
            ],
            key=lambda f: f.name,
        )

        for file in example_files:
            log.debug(f"Adding example from {file}")
            COMMIT_PROMPT += "\n\n" + file.read_text().strip() + "\n\n"
    else:
        log.debug(f"'examples' directory does not exist in {config_dir}")

    exclusions_file = config_dir / EXCLUSIONS_FILE
    if exclusions_file.exists():
        log.debug("Loading exclusions")
        EXCLUDED_FILES = [
            line.strip()
            for line in exclusions_file.read_text().splitlines()
            if line.strip()
        ]
    else:
        log.debug(f"'{EXCLUSIONS_FILE}' does not exist in {config_dir.absolute()}")

    commit_suffix_file = config_dir / COMMIT_SUFFIX_FILE
    if commit_suffix_file.exists():
        log.debug("Loading custom commit suffix")
        # GitHub requires two blank lines before trailers for some features to work correctly
        # See: https://github.com/orgs/community/discussions/143092
        # Note: This may require `git commit --cleanup=verbatim` to prevent git from collapsing the blank lines.
        COMMIT_SUFFIX = "\n\n\n" + commit_suffix_file.read_text().strip()
    else:
        log.debug(f"'{COMMIT_SUFFIX_FILE}' does not exist in {config_dir.absolute()}")


def get_diff_size(section: List[str]) -> int:
    """Calculate the number of changed lines in a diff section."""
    try:
        i = next(j for j, line in enumerate(section) if line.startswith("@@"))
        return sum(
            1 for line in section[i:] if line.startswith("+") or line.startswith("-")
        )
    except StopIteration:
        return 0


def sort_git_diff(diff_str: str) -> str:
    """Sort git diff string by number of changed lines, smallest first."""
    if not diff_str:
        return diff_str

    lines: List[str] = diff_str.splitlines()
    sections: List[List[str]] = []
    current_section: List[str] = []

    for line in lines:
        if line.startswith("diff --git"):
            if current_section:
                sections.append(current_section)
            current_section = [line]
        else:
            current_section.append(line)
    if current_section:
        sections.append(current_section)

    sorted_sections: List[List[str]] = sorted(sections, key=get_diff_size)
    return "\n".join("\n".join(section) for section in sorted_sections)


def get_diff(ignore_whitespace=True, use_difftastic=False):
    """
    Generate diff for staged changes.

    Args:
        ignore_whitespace: If True, ignore whitespace changes (git diff only)
        use_difftastic: If True, use difftastic for syntax-aware diff

    Returns:
        Diff string, using difftastic if requested, otherwise standard git diff
    """
    # Use difftastic if requested (caller should verify availability first)
    if use_difftastic:
        return get_difftastic_diff(EXCLUDED_FILES)

    # Standard git diff (existing implementation)
    arguments = [
        "git",
        "--no-pager",
        "diff",
        "--staged",
    ]
    if ignore_whitespace:
        arguments += [
            "--ignore-space-change",
            "--ignore-blank-lines",
        ]

    for file in EXCLUDED_FILES:
        arguments += [f":(exclude)**{file}"]

    log.debug(f"Running git diff command: {arguments}")

    diff_process = run_command(arguments)
    diff_process.check_returncode()
    normalized_diff = diff_process.stdout.strip()

    # Sort the diff output by size (smallest diffs first)
    sorted_diff = sort_git_diff(normalized_diff)

    log.debug(f"Discovered Diff (sorted by size):\n{sorted_diff}")

    return sorted_diff


def complete(prompt, diff):
    if len(diff) > PROMPT_CUTOFF:
        log.info(
            f"Prompt length ({len(diff)}) exceeds the maximum allowed length, truncating."
        )

    # Allow custom provider settings via environment variables
    # Pydantic AI automatically handles OPENAI_API_KEY, ANTHROPIC_API_KEY, etc.
    # but we map our legacy/custom prefixes if they exist and standard ones don't

    # Create the agent with the configured model
    agent = Agent(MODEL_NAME, system_prompt=prompt)

    model_settings = None
    from pydantic_ai.models.google import GoogleModel
    if isinstance(agent.model, GoogleModel):
        # Configure minimal thinking budget for Gemini models
        # https://ai.pydantic.dev/models/google/#application-default-credentials
        from pydantic_ai.models.google import GoogleModelSettings

        model_settings = GoogleModelSettings(
            # include_thoughts=True improves accuracy via CoT and is filtered out of result.output by pydantic-ai
            google_thinking_config={"include_thoughts": True, "thinking_level": "minimal"}
        )

    # Run the agent synchronously
    result = agent.run_sync(diff[:PROMPT_CUTOFF], model_settings=model_settings)

    # Pydantic AI returns a RunResult object, we need the output data
    completion = result.output

    if completion is None:
        return ""
    return completion.strip()


def generate_commit_message(diff):
    if not diff:
        log.debug("No commit message generated")
        return ""

    message = complete(COMMIT_PROMPT, diff)
    # If the generated message is empty, do not add the commit suffix.
    if not message.strip() or message.strip() == '""':
        return ""
    return message + COMMIT_SUFFIX


def git_commit(message):
    # will ignore message if diff is empty
    return run_command(
        ["git", "commit", "--message", message, "--edit"],
        capture_output=False,
    ).returncode


def get_git_dir():
    try:
        return Path(
            run_command(
                ["git", "rev-parse", "--git-dir"],
                check=True,
            ).stdout.strip()
        )
    except subprocess.CalledProcessError:
        return None


def is_reversion(commit_msg_path=None):
    git_dir = get_git_dir()
    if not git_dir:
        return False

    # Check if we're in the middle of a git revert
    if (git_dir / "REVERT_HEAD").exists():
        return True

    # Or a merge
    if (git_dir / "MERGE_MSG").exists():
        return True

    # Detect fixup commits by checking if the commit message starts with "fixup!"
    # If commit_msg_path is provided, use it. If not, we don't want to use the stale COMMIT_EDITMSG.
    if not commit_msg_path:
        return False

    commit_editmsg = Path(commit_msg_path)

    if commit_editmsg.exists():
        try:
            first_line = commit_editmsg.read_text(
                encoding="utf-8", errors="ignore"
            ).splitlines()[0]
            if first_line.startswith("fixup!"):
                return True
        except IndexError:
            pass

        # Check if a commit amend is happening by comparing the commit edit message
        # with the last commit message (which is pre-populated during amend)
        try:
            current_first_line = (
                commit_editmsg.read_text(encoding="utf-8", errors="ignore")
                .splitlines()[0]
                .strip()
            )
            head_first_line = (
                run_command(
                    ["git", "log", "-1", "--pretty=%B"],
                )
                .stdout.splitlines()[0]
                .strip()
            )
            if current_first_line == head_first_line:
                return True
        except Exception:
            pass

    return False


def check_lock_files():
    """
    Check if only lock files are changed and return a standard commit message if so.
    """
    staged_files = get_staged_files()
    if not staged_files:
        return None

    # check if all changed files are lock files
    lock_files = []
    for file_path in staged_files:
        filename = Path(file_path).name
        if filename in LOCK_FILE_MESSAGES:
            lock_files.append(filename)
        else:
            # If any file is not a recognized lock file, we can't use a static message
            return None

    # If we are here, all staged files are recognized lock files
    unique_messages = {LOCK_FILE_MESSAGES[f] for f in lock_files}

    if len(unique_messages) == 1:
        return unique_messages.pop() + COMMIT_SUFFIX

    return "chore(deps): update lock files" + COMMIT_SUFFIX


@click.group(invoke_without_command=True)
@click.version_option(version=__version__)
def main():
    """
    Generate a commit message for staged files and commit them.
    Git will prompt you to edit the generated commit message.
    """
    ctx = click.get_current_context()
    if ctx.invoked_subcommand is None:
        ctx.invoke(commit)


def get_staged_files() -> List[str]:
    """Get a list of all staged files."""
    result = run_command(["git", "diff", "--staged", "--name-only"])
    return result.stdout.strip().splitlines()


@main.command()
@click.option(
    "-p",
    "--print-message",
    is_flag=True,
    default=False,
    help="print commit msg to stdout instead of performing commit",
)
@click.option(
    "-o",
    "--output-file",
    type=click.Path(writable=True),
    help="write commit message to specified file",
)
@click.option(
    "--config-dir",
    type=click.Path(exists=True, file_okay=False, dir_okay=True),
    help="specify custom config directory",
)
@click.option(
    "--difftastic",
    is_flag=True,
    default=False,
    help="use difftastic for syntax-aware diff analysis (requires difftastic to be installed)",
)
def commit(print_message, output_file, config_dir, difftastic):
    """
    Generate commit message from git diff.
    """

    # click.get_current_context().exit() is used instead of sys.exit() because it's the
    # idiomatic way to exit in Click, allowing for proper context cleanup and better testability.
    if is_reversion(output_file):
        click.get_current_context().exit(0)

    configure_prompts(config_dir)

    # Support environment variable to enable difftastic by default
    use_difftastic = difftastic or os.environ.get(
        "AIAUTOCOMMIT_DIFFTASTIC", ""
    ).lower() in ("1", "true", "yes")

    # Check if difftastic is requested but not available
    if use_difftastic and not shutil.which("difft"):
        log.warning(
            "difftastic was requested but is not installed, falling back to standard git diff"
        )
        use_difftastic = False

    try:
        staged_diff = get_diff(ignore_whitespace=False, use_difftastic=use_difftastic)

        if not staged_diff:
            # If no staged diff (likely due to exclusions), check if we have any staged files
            # that we can handle with a static commit message.
            if lock_message := check_lock_files():
                commit_message = lock_message
                log.info(f"Detected lock file change, using message: {commit_message}")
            else:
                click.echo(
                    "No changes staged. Use `git add` to stage files before invoking aiautocommit.",
                    err=True,
                )
                click.get_current_context().exit(1)
        else:
            diff = get_diff(use_difftastic=use_difftastic)
            if not diff:
                commit_message = "style: whitespace change" + COMMIT_SUFFIX
            else:
                try:
                    wait_for_internet_connection()
                except Exception:
                    log.warning("No internet connection. Skipping AI completion.")
                    click.get_current_context().exit(0)

                commit_message = generate_commit_message(diff)
    except UnicodeDecodeError:
        click.echo("aiautocommit does not support binary files", err=True)

        commit_message = (
            # TODO use heredoc
            "# aiautocommit does not support binary files. "
            "Please enter a commit message manually or unstage any binary files."
        )

    if output_file:
        if commit_message:
            Path(output_file).write_text(commit_message)
            click.get_current_context().exit(0)
        click.get_current_context().exit(1)
    elif print_message:
        click.echo(commit_message)
        click.get_current_context().exit(0)
    else:
        click.get_current_context().exit(git_commit(commit_message))


@main.command()
@click.option(
    "--overwrite",
    is_flag=True,
    help="Overwrite existing pre-commit hook if it exists",
)
def install_pre_commit(overwrite):
    """Install pre-commit script into git hooks directory"""
    git_result = run_command(
        ["git", "rev-parse", "--git-dir"],
        check=True,
    )

    git_dir = git_result.stdout.strip()

    target_hooks_dir = Path(git_dir) / "hooks"
    target_hooks_dir.mkdir(exist_ok=True)

    commit_msg_git_hook_name = "prepare-commit-msg"
    pre_commit = target_hooks_dir / commit_msg_git_hook_name
    pre_commit_script = Path(__file__).parent / commit_msg_git_hook_name

    if not pre_commit.exists() or overwrite:
        pre_commit.write_text(pre_commit_script.read_text())
        pre_commit.chmod(0o755)
        click.echo("Installed pre-commit hook")
    else:
        click.echo(
            "pre-commit hook already exists. Here's the contents we would have written:\n"
        )
        click.echo(pre_commit_script.read_text())


@main.command()
def dump_prompts():
    "Dump default prompts by copying the contents of the prompt directory to PWD for customization"

    config_dir = Path(LOCAL_REPO_AUTOCOMMIT_DIR_NAME)
    config_dir.mkdir(exist_ok=True)
    source_prompt_dir = Path(__file__).parent / "prompt"

    if not source_prompt_dir.exists():
        click.echo("Source prompt directory does not exist; nothing to copy.")
        return

    # Copy each item from source_prompt_dir into config_dir
    for item in source_prompt_dir.iterdir():
        target = config_dir / item.name
        if target.exists():
            click.echo(f"{target} already exists. Skipping copy of {item.name}.")
            continue
        if item.is_dir():
            shutil.copytree(item, target)
        else:
            shutil.copy(item, target)

    click.echo(f"Copied contents of {source_prompt_dir} to {config_dir}")


@main.command()
def output_prompt():
    "Dump compiled prompt, helpful for debugging"

    configure_prompts()
    click.echo(COMMIT_PROMPT)


@main.command()
def output_exclusions():
    "Dump file exclusions, helpful for debugging"

    configure_prompts()
    click.echo(EXCLUDED_FILES)


@main.command()
@click.argument("sha")
@click.argument("message")
def debug_prompt(sha, message):
    """
    Show debug info for a given commit SHA:
    - the git diff as a Markdown block
    - the entire prompt as a Markdown block
    - the full commit message
    """
    configure_prompts()

    diff_cmd = ["git", "show", sha, "--pretty="]
    diff_output = run_command(diff_cmd).stdout

    commit_msg_cmd = ["git", "log", "--format=%B", "-n", "1", sha]
    commit_message = run_command(commit_msg_cmd).stdout

    # remove the fixed commit suffix
    commit_message = commit_message.replace(COMMIT_SUFFIX, "").strip()

    click.echo(f"""
Your job is to help me improve a prompt that is being sent to an LLM in order to write a get commit message.

{message}

Explain why and suggest a improved prompt (without examples) in a markdown block. Keep your response concise.

Here is the diff:

```
{diff_output}
```

Here was the commit message that was generated:

```
{commit_message}
```

It was written using the following LLM prompt:

---

{COMMIT_PROMPT}
""")

import logging
import os
import re
import subprocess
import sys
import warnings
from pathlib import Path

import click
from openai import OpenAI

# Config file locations in priority order
LOCAL_REPO_AUTOCOMMIT_DIR_NAME = ".aiautocommit"
CONFIG_PATHS = [
    Path(LOCAL_REPO_AUTOCOMMIT_DIR_NAME),  # $PWD/.aiautocommit
    Path(os.environ.get("XDG_CONFIG_HOME", "~/.config")).expanduser()
    / "aiautocommit",  # XDG config dir
    Path(__file__).parent / "prompt",  # package config dir
]

if custom_config_path := os.environ.get("AIAUTOCOMMIT_CONFIG", None):
    CONFIG_PATHS.insert(-2, Path(custom_config_path))

COMMIT_PROMPT_FILE = "commit_prompt.txt"
EXCLUSIONS_FILE = "exclusions.txt"
COMMIT_SUFFIX_FILE = "commit_suffix.txt"

# https://platform.openai.com/docs/models
# gpt-4o-mini is cheaper, basically free
MODEL_NAME = os.environ.get("AIAUTOCOMMIT_MODEL", "gpt-4o")

COMMIT_PROMPT = ""
EXCLUDED_FILES = []

# trailers are a native git feature that can be used to add metadata to a commit
# https://git-scm.com/docs/git-interpret-trailers
# let's indicate that this message was generated by aiautocommit
COMMIT_SUFFIX = """

Generated-by: aiautocommit
"""

# characters, not tokens
PROMPT_CUTOFF = 10_000

logging.basicConfig(
    level=os.environ.get("LOG_LEVEL", "INFO").upper(),
    **(
        {"filename": os.environ.get("AIAUTOCOMMIT_LOG_PATH")}
        if os.environ.get("AIAUTOCOMMIT_LOG_PATH")
        else {"stream": sys.stderr}
    ),
)

# this is called within py dev environments. Unless it looks like we are explicitly debugging aiautocommit, we force a
# more silent operation. Checking for AIAUTOCOMMIT_LOG_PATH is not a perfect heuristic, but it works for now.
if not os.environ.get("AIAUTOCOMMIT_LOG_PATH"):
    # Suppress ResourceWarnings
    warnings.filterwarnings("ignore", category=ResourceWarning)

    # Optional: Disable httpx logging if desired
    logging.getLogger("httpx").setLevel(logging.WARNING)

# allow a unique API key to be set for OpenAI, for tracking/costing
if os.environ.get("AIAUTOCOMMIT_OPENAI_API_KEY"):
    os.environ["OPENAI_API_KEY"] = os.environ["AIAUTOCOMMIT_OPENAI_API_KEY"]


def configure_prompts(config_dir=None):
    breakpoint()
    global COMMIT_PROMPT, COMMIT_SUFFIX, EXCLUDED_FILES, CONFIG_PATHS

    # Use custom config_dir if provided; otherwise use the default prompt directory
    if config_dir:
        CONFIG_PATHS.insert(0, Path(config_dir))

    # Find first existing config dir
    config_dir = next((path for path in CONFIG_PATHS if path and path.exists()), None)

    if not config_dir:
        logging.debug("No config directory found")
        return

    logging.debug(f"Found config directory at {config_dir}")

    commit_file = config_dir / "commit_prompt.txt"
    if commit_file.exists():
        logging.debug("Loading commit prompt")
        COMMIT_PROMPT = commit_file.read_text().strip()

    examples_dir = config_dir / "examples"
    if examples_dir.exists():
        logging.debug("Loading examples")
        pattern = re.compile(r"example_\d\.md$")
        example_files = sorted(
            [
                file
                for file in examples_dir.iterdir()
                if file.is_file() and pattern.match(file.name)
            ],
            key=lambda f: f.name,
        )

        for file in example_files:
            logging.debug(f"Adding example from {file}")
            COMMIT_PROMPT += "\n\n" + file.read_text().strip() + "\n\n"

    exclusions_file = config_dir / "exclusions.txt"
    if exclusions_file.exists():
        logging.debug("Loading exclusions")
        EXCLUDED_FILES = [
            line.strip()
            for line in exclusions_file.read_text().splitlines()
            if line.strip()
        ]

    commit_suffix_file = config_dir / "commit_suffix.txt"
    if commit_suffix_file.exists():
        logging.debug("Loading custom commit suffix")
        COMMIT_SUFFIX = commit_suffix_file.read_text().strip()


def get_diff(ignore_whitespace=True):
    """Generate diff for staged changes (ignores whitespace and file exclusions)."""

    arguments = [
        "git",
        "--no-pager",
        "diff",
        "--staged",
    ]
    if ignore_whitespace:
        arguments += [
            "--ignore-space-change",
            "--ignore-blank-lines",
        ]

    for file in EXCLUDED_FILES:
        arguments += [f":(exclude){file}"]

    diff_process = subprocess.run(arguments, capture_output=True, text=True)
    diff_process.check_returncode()
    normalized_diff = diff_process.stdout.strip()

    logging.debug(f"Discovered Diff:\n{normalized_diff}")

    return normalized_diff


def complete(prompt, diff):
    if len(diff) > PROMPT_CUTOFF:
        logging.warning(
            f"Prompt length ({len(diff)}) exceeds the maximum allowed length, truncating."
        )

    client = OpenAI()
    completion_resp = client.chat.completions.create(
        model=MODEL_NAME,
        messages=[
            # TODO not all models support system vs user messages...
            {"role": "system", "content": prompt},
            {"role": "user", "content": diff[:PROMPT_CUTOFF]},
        ],
        # TODO this seems awfully small?
        # max_completion_tokens=128,
    )

    completion = completion_resp.choices[0].message.content.strip()
    return completion


def generate_commit_message(diff):
    if not diff:
        logging.debug("No commit message generated")
        return ""

    return (complete(COMMIT_PROMPT, diff)) + COMMIT_SUFFIX


def git_commit(message):
    # will ignore message if diff is empty
    return subprocess.run(["git", "commit", "--message", message, "--edit"]).returncode


def is_reversion():
    # Check if we're in the middle of a git revert
    if (Path(".git") / "REVERT_HEAD").exists():
        return True

    # Or a merge
    if (Path(".git") / "MERGE_MSG").exists():
        return True

    return False


@click.group(invoke_without_command=True)
def main():
    """
    Generate a commit message for staged files and commit them.
    Git will prompt you to edit the generated commit message.
    """
    ctx = click.get_current_context()
    if ctx.invoked_subcommand is None:
        ctx.invoke(commit)


@main.command()
@click.option(
    "-p",
    "--print-message",
    is_flag=True,
    default=False,
    help="print commit msg to stdout instead of performing commit",
)
@click.option(
    "-o",
    "--output-file",
    type=click.Path(writable=True),
    help="write commit message to specified file",
)
@click.option(
    "--config-dir",
    type=click.Path(exists=True, file_okay=False, dir_okay=True),
    help="specify custom config directory",
)
def commit(print_message, output_file, config_dir):
    """
    Generate commit message from git diff.
    """

    if is_reversion():
        return 0

    configure_prompts(config_dir)

    try:
        if not get_diff(ignore_whitespace=False):
            click.echo(
                "No changes staged. Use `git add` to stage files before invoking gpt-commit.",
                err=True,
            )
            return 1

        commit_message = generate_commit_message(get_diff())
    except UnicodeDecodeError:
        click.echo("aiautocommit does not support binary files", err=True)

        commit_message = (
            # TODO use heredoc
            "# gpt-commit does not support binary files. "
            "Please enter a commit message manually or unstage any binary files."
        )

    if output_file:
        if commit_message:
            Path(output_file).write_text(commit_message)
            return 0
        return 1
    elif print_message:
        click.echo(commit_message)
        return 0
    else:
        return git_commit(commit_message)


@main.command()
@click.option(
    "--overwrite",
    is_flag=True,
    help="Overwrite existing pre-commit hook if it exists",
)
def install_pre_commit(overwrite):
    """Install pre-commit script into git hooks directory"""
    git_result = subprocess.run(
        ["git", "rev-parse", "--git-dir"],
        capture_output=True,
        text=True,
    )
    git_result.check_returncode()

    git_dir = git_result.stdout.strip()

    target_hooks_dir = Path(git_dir) / "hooks"
    target_hooks_dir.mkdir(exist_ok=True)

    commit_msg_git_hook_name = "prepare-commit-msg"
    pre_commit = target_hooks_dir / commit_msg_git_hook_name
    pre_commit_script = Path(__file__).parent / commit_msg_git_hook_name

    if not pre_commit.exists() or overwrite:
        pre_commit.write_text(pre_commit_script.read_text())
        pre_commit.chmod(0o755)
        click.echo("Installed pre-commit hook")
    else:
        click.echo(
            "pre-commit hook already exists. Here's the contents we would have written:\n"
        )
        click.echo(pre_commit_script.read_text())


@main.command()
def dump_prompts():
    "Dump default prompts into .aiautocommit directory for easy customization"

    config_dir = Path(LOCAL_REPO_AUTOCOMMIT_DIR_NAME)
    config_dir.mkdir(exist_ok=True)

    commit_prompt = config_dir / COMMIT_PROMPT_FILE
    exclusions = config_dir / EXCLUSIONS_FILE
    commit_suffix = config_dir / COMMIT_SUFFIX_FILE

    if not commit_prompt.exists():
        commit_prompt.write_text(COMMIT_PROMPT)
    if not exclusions.exists():
        exclusions.write_text("\n".join(EXCLUDED_FILES))
    if not commit_suffix.exists():
        commit_suffix.write_text(COMMIT_SUFFIX)

    click.echo(
        f"""Dumped default prompts to {LOCAL_REPO_AUTOCOMMIT_DIR_NAME} directory:

- {COMMIT_PROMPT_FILE}: Template for generating commit messages
- {EXCLUSIONS_FILE}: List of file patterns to exclude from processing
- {COMMIT_SUFFIX}: Text appended to the end of every commit message
"""
    )
